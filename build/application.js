/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./axial/js/button/AxialButton.js":
/*!****************************************!*\
  !*** ./axial/js/button/AxialButton.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialButton\": () => (/* binding */ AxialButton)\n/* harmony export */ });\n/* harmony import */ var _AxialButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxialButtonBase */ \"./axial/js/button/AxialButtonBase.js\");\n\r\n\r\n;\r\n\r\nclass AxialButton extends _AxialButtonBase__WEBPACK_IMPORTED_MODULE_0__.AxialButtonBase\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.classList.add(\"axial_button\");\r\n        this.template = \"axial-button-template\";\r\n    }\r\n\r\n    static get observedAttributes()\r\n    {\r\n        return [\"ax-label\"];\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-button\", AxialButton);\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialButton.js?");

/***/ }),

/***/ "./axial/js/button/AxialButtonBase.js":
/*!********************************************!*\
  !*** ./axial/js/button/AxialButtonBase.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialButtonBase\": () => (/* binding */ AxialButtonBase)\n/* harmony export */ });\n/* harmony import */ var _core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxialComponentBase */ \"./axial/js/core/AxialComponentBase.js\");\n\r\n\r\n;\r\n\r\nclass AxialButtonBase extends _core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__.AxialComponentBase\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.classList.add(\"axial_button_base\");\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-button-base\", AxialButtonBase);\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialButtonBase.js?");

/***/ }),

/***/ "./axial/js/button/AxialToggleButtonBase.js":
/*!**************************************************!*\
  !*** ./axial/js/button/AxialToggleButtonBase.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialToggleButtonBase\": () => (/* binding */ AxialToggleButtonBase)\n/* harmony export */ });\n/* harmony import */ var _AxialButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxialButtonBase */ \"./axial/js/button/AxialButtonBase.js\");\n/* harmony import */ var _AxialToggleButtonGroupBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AxialToggleButtonGroupBase */ \"./axial/js/button/AxialToggleButtonGroupBase.js\");\n\r\n\r\n;\r\n\r\n\r\nclass AxialToggleButtonBase extends _AxialButtonBase__WEBPACK_IMPORTED_MODULE_0__.AxialButtonBase\r\n{\r\n    // events\r\n    #boundToggleClickHandler;\r\n\r\n    /** @type { Boolean } */\r\n    #selected = false;\r\n\r\n    /** @type { AxialToggleButtonGroupBase } */\r\n    #buttonGroup = undefined;\r\n    \r\n    constructor()\r\n    {\r\n        super();\r\n        this.#boundToggleClickHandler = this.#toggleClickHandler.bind(this);\r\n        this.addEventListener(\"click\", this.#boundToggleClickHandler);\r\n    }\r\n\r\n    get selected() { return this.#selected; }\r\n    set selected( value )\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value expected\");\r\n        }\r\n        if( value == this.#selected ) { return; }\r\n        this.#selected = value;\r\n        this._onToggleChanged();\r\n    }\r\n\r\n    get buttonGroup() { return this.#buttonGroup; }\r\n    set buttonGroup( value )\r\n    {\r\n        \r\n        if( value instanceof _AxialToggleButtonGroupBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonGroupBase == false )\r\n        {\r\n            throw new TypeError(\"AxialToggleButtonGroupBase value expected\");\r\n        }\r\n        \r\n        if( value == this.#buttonGroup ) { return; }\r\n\r\n        /// TODO : remove from previous button group is the toggle is already on a group ;)\r\n        this.#buttonGroup = value;\r\n        this.#buttonGroup.add(this);\r\n    }\r\n\r\n    #toggleClickHandler( event )\r\n    {\r\n        if( this.#selected == true && this.#buttonGroup != undefined && this.#buttonGroup.forceSelection == true )\r\n        {\r\n            return;\r\n        }\r\n        this.#selected = !this.#selected;\r\n\r\n        this._onToggleChanged();\r\n\r\n        const toggleChangedEvent = new CustomEvent(\"toggleChanged\");\r\n        this.dispatchEvent(toggleChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Manage styles and other stuff here\r\n     * @override\r\n     */\r\n    _onToggleChanged() {}\r\n\r\n}\r\n\r\nwindow.customElements.define(\"axial-toggle-button-base\", AxialToggleButtonBase);\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialToggleButtonBase.js?");

/***/ }),

/***/ "./axial/js/button/AxialToggleButtonGroupBase.js":
/*!*******************************************************!*\
  !*** ./axial/js/button/AxialToggleButtonGroupBase.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialToggleButtonGroupBase\": () => (/* binding */ AxialToggleButtonGroupBase)\n/* harmony export */ });\n/* harmony import */ var _core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxialComponentBase */ \"./axial/js/core/AxialComponentBase.js\");\n/* harmony import */ var _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AxialToggleButtonBase */ \"./axial/js/button/AxialToggleButtonBase.js\");\n\r\n\r\n;\r\n\r\n\r\nclass AxialToggleButtonGroupBase extends _core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__.AxialComponentBase\r\n{\r\n    #boundToggleChangedHandler;\r\n\r\n    /** @type { Array<AxialToggleButtonBase> } */\r\n    #toggles = new Array();\r\n\r\n    /** @type { Number } */\r\n    #selectedIndex = -1;\r\n\r\n    /** @type { Boolean } */\r\n    #forceSelection = false;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.#boundToggleChangedHandler = this.#toggleChangedHandler.bind(this);\r\n        console.log(\"end group base constructor\");\r\n    }\r\n\r\n    _finalizeComponent()\r\n    {\r\n        super._finalizeComponent();\r\n        const tempToggles = this.children;\r\n        const tempTogglesLength = tempToggles.length;\r\n\r\n        if( tempTogglesLength > 0 )\r\n        {\r\n            for( let i = 0; i < tempTogglesLength; i++ )\r\n            {\r\n                const tempToggle = tempToggles[i];\r\n                this.add(tempToggle);\r\n                if( tempToggle instanceof _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonBase === true )\r\n                {\r\n                    this.add(tempToggle);\r\n                }\r\n                else\r\n                {\r\n                    throw new Error(\"Elements in an AxialToggleButtonGroupBase must be or extends AxialToggleButtonBase\");\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the current AxialToggleButtonBase in the group.\r\n     * @type { Array<AxialToggleButtonBase> }\r\n     * @public\r\n     * @readonly\r\n     */\r\n    get toggles() { return Array.from(this.#toggles); }\r\n\r\n    /**\r\n     * Get or set the selected button by index.\r\n     * @type { Number }\r\n     * @public\r\n     */\r\n    get selectedIndex() { return this.#selectedIndex; }\r\n    set selectedIndex( value ) \r\n    {\r\n        if( isNaN(value) == true )\r\n        {\r\n            throw new TypeError( \"Number value expected\" );\r\n        }\r\n\r\n        const togglesLength = this.#toggles.length;\r\n        if( togglesLength == 0 || value > togglesLength ) { return; }\r\n\r\n        // ensure _selectedIndex has the correct value (-1 if < 0)\r\n        this.#selectedIndex = value < 0 ? -1 : value;\r\n\r\n        for( let i = 0; i < togglesLength; i++ )\r\n        {\r\n            let currentToggle = this.#toggles[i];\r\n            if( this.#selectedIndex == i )\r\n            {\r\n                currentToggle.selected = true;\r\n            }\r\n            else\r\n            {\r\n                currentToggle.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getSelectedToggle()\r\n    {\r\n        if( this.#selectedIndex == -1 ) { return undefined; }\r\n        return this.#toggles[this.#selectedIndex];\r\n    }\r\n\r\n    /**\r\n     * Ensure we have always one button selected once the user has interacted with the group.\r\n     * @type { Boolean }\r\n     */\r\n    get forceSelection() { return this.#forceSelection; }\r\n    set forceSelection( value )\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value expected\");\r\n        }\r\n        if( value == this.#forceSelection ) { return; }\r\n        this.#forceSelection = value;\r\n\r\n        // TODO ? what we do if no toggles already selected\r\n    }\r\n\r\n    /**\r\n     * Select the AxialToggleButtonBase in the group.\r\n     * Silent fail if the toggleButton is not in the group.\r\n     * @param { AxialToggleButtonBase } toggle\r\n     */\r\n    select( toggle )\r\n    {\r\n        if( toggle instanceof _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonBase == false )\r\n        {\r\n            throw new TypeError( \"AxialToggleButtonBase value expected\" );\r\n        }\r\n\r\n        const togglesLength = this.#toggles.length;\r\n        if( togglesLength == 0 ) { return; }\r\n        if( this.#toggles.includes( toggle ) == false ) { return; }\r\n        \r\n        for( let i = 0; i < togglesLength; i++ )\r\n        {\r\n            let currentToggle = this.#toggles[i];\r\n            if( currentToggle == toggle )\r\n            {\r\n                currentToggle.selected = true;\r\n                this.#selectedIndex = i;\r\n            }\r\n            else\r\n            {\r\n                currentToggle.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add an AxialToggleButtonBase to the group if is not already in the group.\r\n     * TODO : If the toggle button is already selected and no button in the group are, then updated the value of selectedIndex\r\n     * If another button is selected, then unselect it and update the value\r\n     * @param { AxialToggleButtonBase } toggle \r\n     */\r\n    add( toggle )\r\n    {\r\n        if( toggle instanceof _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonBase == false )\r\n        {\r\n            throw new TypeError( \"AxialToggleButtonBase value expected\" );\r\n        }\r\n\r\n        if( toggle.buttonGroup == this ) { return; }\r\n\r\n        if( this.#toggles.includes( toggle ) == false )\r\n        {\r\n            toggle.buttonGroup = this;\r\n            this.#toggles.push( toggle );\r\n            toggle.addEventListener(\"toggleChanged\", this.#boundToggleChangedHandler);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an AxialToggleButtonBase from the group (if it's in !).\r\n     * TODO : if the removed button was selected, then update the selectedIndex value\r\n     * @param { AxialToggleButtonBase } toggle \r\n     */\r\n    remove( toggle )\r\n    {\r\n        if( toggle instanceof _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonBase == false )\r\n        {\r\n            throw new TypeError( \"AxialToggleButtonBase value expected\" );\r\n        }\r\n\r\n        const toggleIndex = this.#toggles.indexOf( toggle );\r\n        if( toggleIndex > -1 )\r\n        {\r\n            toggle.removeEventListener(\"toggleChanged\", this.#boundToggleChangedHandler);\r\n            this.#toggles.splice( toggleIndex, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the index of AxialToggleButtonBase in the group. Returns -1 if the button is not in the group.\r\n     * @param { AxialToggleButtonBase } toggle \r\n     * @return { Number }\r\n     */\r\n    getIndexByToggle( toggle )\r\n    {\r\n        if( toggle instanceof _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_1__.AxialToggleButtonBase == false )\r\n        {\r\n            throw new TypeError( \"AxialToggleButtonBase value expected\" );\r\n        }\r\n        return this.#toggles.indexOf( toggle );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param { Event } event \r\n     */\r\n    #toggleChangedHandler( event )\r\n    {\r\n        const toggleChanged = event.currentTarget;\r\n        //console.log(toggleChanged);\r\n        let indexChanged = this.getIndexByToggle( toggleChanged );\r\n        //console.log(indexChanged);\r\n        const toggleSelected = toggleChanged.selected;\r\n        //console.log(toggleSelected);\r\n\r\n        // take care of forceselection\r\n        if( toggleSelected == false )\r\n        {\r\n            indexChanged = -1; // KEEP IMPORTANT\r\n            this.#selectedIndex = -1;\r\n        }\r\n        else\r\n        {\r\n            this.#selectedIndex = indexChanged;\r\n\r\n            // untoggle all others buttons\r\n            const togglesLength = this.#toggles.length;\r\n            for( let i = 0; i < togglesLength; i++ )\r\n            {\r\n                if( i != indexChanged )\r\n                {\r\n                    let currentToggle = this.#toggles[i];\r\n                    currentToggle.selected = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        const indexChangedEvent = new CustomEvent(\"indexChanged\", { detail: { selectedIndex: indexChanged } });\r\n        this.dispatchEvent(indexChangedEvent);\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-toggle-button-group-base\", AxialToggleButtonGroupBase);\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialToggleButtonGroupBase.js?");

/***/ }),

/***/ "./axial/js/button/AxialToggleRadio.js":
/*!*********************************************!*\
  !*** ./axial/js/button/AxialToggleRadio.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialToggleRadio\": () => (/* binding */ AxialToggleRadio)\n/* harmony export */ });\n/* harmony import */ var _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxialToggleButtonBase */ \"./axial/js/button/AxialToggleButtonBase.js\");\n\r\n\r\n;\r\n\r\nclass AxialToggleRadio extends _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_0__.AxialToggleButtonBase\r\n{\r\n    /** @type { HTMLElement } */\r\n    #circle;\r\n\r\n    #unselectedScale = \"scale(0)\";\r\n    #selectedScale = \"scale(1)\";\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.classList.add(\"axial_toggle_radio\");\r\n        this.template = \"axial-toggle-radio-template\";\r\n    }\r\n\r\n    connectedCallback()\r\n    {\r\n        this.#circle = this.shadowRoot.getElementById(\"circle\");\r\n    }\r\n\r\n    _onToggleChanged()\r\n    {\r\n        super._onToggleChanged();\r\n        \r\n        if( this.#circle )\r\n        {\r\n            if( this.selected === true )\r\n            {\r\n                this.#circle.style.transform = this.#selectedScale;\r\n            }\r\n            else\r\n            {\r\n                this.#circle.style.transform = this.#unselectedScale;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-toggle-radio\", AxialToggleRadio);\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialToggleRadio.js?");

/***/ }),

/***/ "./axial/js/button/AxialToggleSwitch.js":
/*!**********************************************!*\
  !*** ./axial/js/button/AxialToggleSwitch.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialToggleSwitch\": () => (/* binding */ AxialToggleSwitch)\n/* harmony export */ });\n/* harmony import */ var _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxialToggleButtonBase */ \"./axial/js/button/AxialToggleButtonBase.js\");\n\r\n\r\n;\r\n\r\nclass AxialToggleSwitch extends _AxialToggleButtonBase__WEBPACK_IMPORTED_MODULE_0__.AxialToggleButtonBase\r\n{\r\n    /** @type { HTMLElement } */\r\n    #circle;\r\n\r\n    #unselectedLeft = \"0px\";\r\n    #selectedLeft = \"30px\";\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.classList.add(\"axial_toggle_switch\");\r\n        this.template = \"axial-toggle-switch-template\";\r\n    }\r\n\r\n    connectedCallback()\r\n    {\r\n        this.#circle = this.shadowRoot.getElementById(\"circle\");\r\n    }\r\n\r\n    _onToggleChanged()\r\n    {\r\n        super._onToggleChanged();\r\n        \r\n        if( this.#circle )\r\n        {\r\n            if( this.selected === true )\r\n            {\r\n                this.#circle.style.left = this.#selectedLeft;\r\n            }\r\n            else\r\n            {\r\n                this.#circle.style.left = this.#unselectedLeft;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-toggle-switch\", AxialToggleSwitch);\r\n\n\n//# sourceURL=webpack:///./axial/js/button/AxialToggleSwitch.js?");

/***/ }),

/***/ "./axial/js/core/AxialApplicationBase.js":
/*!***********************************************!*\
  !*** ./axial/js/core/AxialApplicationBase.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialApplicationBase\": () => (/* binding */ AxialApplicationBase)\n/* harmony export */ });\n/* harmony import */ var _utils_LanguageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/LanguageUtils */ \"./axial/js/utils/LanguageUtils.js\");\n\r\n\r\n/// axial imports\r\n/// please imports all the components classes in the html file where the templates lives OR in the main js application file\r\n\r\n;\r\n\r\n/**\r\n * The main base class for your application.\r\n * @class\r\n * @extends { EventTarget }\r\n */\r\nclass AxialApplicationBase extends EventTarget\r\n{\r\n    /// events\r\n    #boundApplicationDomLoadedHandler;\r\n    #boundApplicationPageLoadedHandler;\r\n    #boundApplicationResizeHandler;\r\n    #boundWindowResizeHandler;\r\n    \r\n    /// properties\r\n    /**\r\n     * @private\r\n     * @type { any }\r\n     * @default undefined\r\n     */\r\n    #data = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #applicationDomLoaded = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #applicationPageLoaded = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #useApplicationResize = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Number }\r\n     * @default null\r\n     */\r\n    #applicationResizeTimeoutId = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Number }\r\n     * @default 400\r\n     */\r\n    #applicationResizeTimeoutDelay = 300;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #isIOS = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #isAndroid = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #isDesktop = false;\r\n\r\n    /**\r\n     * @private \r\n     * @type { String | undefined }\r\n     * @default undefined\r\n     */\r\n    #language = undefined\r\n\r\n    /**\r\n     * Create the main AxialApplicationBase and make it a property of its window.\r\n     * The Application is freezed to avoid interference with others scripts.\r\n     * @constructor\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n        \r\n        if( window.AXIAL === undefined )\r\n        {\r\n            Object.freeze(this);\r\n            window.AXIAL = this;\r\n        }\r\n\r\n        // language\r\n        this.#language = _utils_LanguageUtils__WEBPACK_IMPORTED_MODULE_0__.LanguageUtils.getNavigatorLanguage();\r\n\r\n        // ios\r\n        this.#isIOS = ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\r\n\r\n        // android\r\n        this.#isAndroid = navigator.userAgent.toLowerCase().indexOf(\"android\") >= 0;\r\n\r\n        if( this.#isIOS == false && this.#isAndroid == false )\r\n        {\r\n            this.#isDesktop = true;\r\n        }\r\n\r\n        this.#boundApplicationDomLoadedHandler = this.#applicationDomLoadedHandler.bind(this);\r\n        this.#boundApplicationPageLoadedHandler = this.#applicationPageLoadedHandler.bind(this);\r\n        this.#boundApplicationResizeHandler = this.#applicationResizeHandler.bind(this);\r\n        this.#boundWindowResizeHandler = this.#windowResizeHandler.bind(this);\r\n        \r\n        window.addEventListener(\"DOMContentLoaded\", this.#boundApplicationDomLoadedHandler);\r\n        window.addEventListener(\"load\", this.#boundApplicationPageLoadedHandler);\r\n    }\r\n\r\n    get language() { return this.#language; }\r\n    set language( value )\r\n    {\r\n        if( typeof value !== \"string\" )\r\n        {\r\n            throw new TypeError(\"String value required\");\r\n        }\r\n        if( this.#language == value ) { return; }\r\n        this.#language = value;\r\n        this._onApplicationLanguageChanged();\r\n        const languageChangedEvent = new CustomEvent(\"languageChanged\");\r\n        this.dispatchEvent(languageChangedEvent);\r\n    }\r\n\r\n    _onApplicationLanguageChanged()\r\n    {\r\n        //console.log(\"AxialApplicationBase._onApplicationLanguageChanged()\");\r\n    }\r\n\r\n    ///\r\n    /// PART: ENV\r\n    ///\r\n\r\n    get isIOS() { return this.#isIOS; }\r\n\r\n    get isAndroid() { return this.#isAndroid; }\r\n\r\n    get isDesktop() { return this.#isDesktop; }\r\n\r\n    ///\r\n    /// PART: DATA\r\n    ///\r\n\r\n    /**\r\n     * Get or set data to the application.\r\n     * @type { any }\r\n     * @param { any } value \r\n     */\r\n    get data()\r\n    {\r\n        return this.#data;\r\n    }\r\n    set data( value )\r\n    {\r\n        if( this.#data == value ) { return; }\r\n        this.#data = value;\r\n        this._onApplicationDataChanged();\r\n        const dataChangedEvent = new CustomEvent(\"applicationDataChanged\", { detail: this.#data });\r\n        this.dispatchEvent(dataChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * This method is called once the data property has just been setted and before the AxialApplicationBase dispatches the dataChanged Custom Event.\r\n     * @public\r\n     * @abstract\r\n     */\r\n    _onApplicationDataChanged()\r\n    {\r\n        //console.log(\"AxialApplicationBase._onApplicationDataChanged()\");\r\n    }\r\n\r\n    ///\r\n    /// PART: DOM LOADED\r\n    ///\r\n    \r\n    /**\r\n     * Get the DOMContentLoaded status of the window, bounded into the Axial application.\r\n     * @public\r\n     * @type { Boolean }\r\n     * @readonly\r\n     */\r\n    get applicationDomLoaded() { return this.#applicationDomLoaded; }\r\n\r\n    /**\r\n     * The internal DOMContentLoaded handler bounded in the AxialApplicationBase for its lifecycle.\r\n     * Call its associated _onApplicationDomLoaded method.\r\n     * @private\r\n     */\r\n    #applicationDomLoadedHandler(event)\r\n    {\r\n        this.#applicationDomLoaded = true;\r\n\r\n        if( this._onApplicationDomLoaded )\r\n        {\r\n            this._onApplicationDomLoaded(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is called once the window DOMContentLoaded event is fired. You can perform some actions on the DOM here.\r\n     * If you have declared some component in your html files, these are on the DOM and you can manipulate them.\r\n     * @public\r\n     * @param { Event } event - The DOMContentLoaded event of the window.\r\n     * @abstract\r\n     */\r\n    _onApplicationDomLoaded(event)\r\n    {\r\n        //console.log(\"AxialApplicationBase._onApplicationDomLoaded()\");\r\n    }\r\n\r\n    ///\r\n    /// PART: PAGE LOADED\r\n    ///\r\n\r\n    /**\r\n     * Get the load status of the window, bounded into the Axial application.\r\n     * @public\r\n     * @type { Boolean }\r\n     * @readonly\r\n     */\r\n    get applicationPageLoaded() { return this.#applicationPageLoaded; }\r\n\r\n    /**\r\n     * The internal load handler bounded in the AxialApplicationBase for its lifecycle.\r\n     * Call its associated _onApplicationPageLoaded method.\r\n     * @private\r\n     */\r\n    #applicationPageLoadedHandler(event)\r\n    {\r\n        this.#applicationPageLoaded = true;\r\n\r\n        if( this._onApplicationPageLoaded )\r\n        {\r\n            this._onApplicationPageLoaded(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is called once the window load event is fired. You can really start your application here :)\r\n     * @public\r\n     * @param { Event } event - The load event of the window.\r\n     * @abstract\r\n     */\r\n    _onApplicationPageLoaded(event)\r\n    {\r\n        //console.log(\"AxialApplicationBase._onApplicationPageLoaded()\");\r\n    }\r\n\r\n    get useApplicationResize() { return this.useApplicationResize; }\r\n    set useApplicationResize( value )\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value required\");\r\n        }\r\n        if( this.#useApplicationResize == value ) { return; }\r\n        this.#useApplicationResize = value;\r\n        \r\n        if( this.#useApplicationResize == false )\r\n        {\r\n            window.removeEventListener(\"resize\", this.#boundWindowResizeHandler);\r\n        }\r\n        else\r\n        {\r\n            window.addEventListener(\"resize\", this.#boundWindowResizeHandler);\r\n        }\r\n    }\r\n\r\n    #windowResizeHandler( event )\r\n    {\r\n        if( this.#applicationResizeTimeoutId !== null )\r\n        {\r\n            clearTimeout(this.#applicationResizeTimeoutId);\r\n        }\r\n        this.#boundApplicationResizeHandler();\r\n        this.#applicationResizeTimeoutId = setTimeout( this.#boundApplicationResizeHandler, this.#applicationResizeTimeoutDelay);\r\n\r\n    }\r\n\r\n    #applicationResizeHandler( event )\r\n    {\r\n        this.#applicationResizeTimeoutId = null;\r\n\r\n        if( this._onApplicationResize )\r\n        {\r\n            this._onApplicationResize();\r\n            \r\n        }\r\n    }\r\n\r\n    _onApplicationResize()\r\n    {\r\n        console.log(\"AxialApplicationBase._onApplicationResize()\");\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/core/AxialApplicationBase.js?");

/***/ }),

/***/ "./axial/js/core/AxialComponentBase.js":
/*!*********************************************!*\
  !*** ./axial/js/core/AxialComponentBase.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxialComponentBase\": () => (/* binding */ AxialComponentBase)\n/* harmony export */ });\n/* harmony import */ var _geom_Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/Point */ \"./axial/js/geom/Point.js\");\n\r\n\r\n/// axial imports\r\n;\r\n\r\n/**\r\n * The main base class for all components.\r\n * @class\r\n * @extends { HTMLElement }\r\n */\r\nclass AxialComponentBase extends HTMLElement\r\n{\r\n    /// static\r\n    static #MANIPULATION_TYPES = Object.freeze( new Set([\"none\", \"swipe\"]) );\r\n\r\n    /// events\r\n    // dom (for lifecycle in specific cases) /// TEST PURPOSE\r\n    #boundDomLoadedHandler;\r\n    // resize\r\n    #boundResizeHandler;\r\n    // manipulation\r\n    #boundManipulationEnterHandler;\r\n    #boundManipulationDownHandler;\r\n    #boundManipulationOverHandler;\r\n    #boundManipulationMoveHandler;\r\n    #boundManipulationOutHandler;\r\n    #boundManipulationUpHandler;\r\n    #boundManipulationLeaveHandler;\r\n    #boundManipulationCancelHandler;\r\n\r\n    /// properties\r\n    /**\r\n     * @private\r\n     * @type { undefined | null | Object }\r\n     * @default undefined\r\n     */\r\n    #data = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #isResizable = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { Set }\r\n     */\r\n    #states = new Set([\"init\"]);\r\n\r\n    /**\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #useStates = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type { String }\r\n     * @default \"\"\r\n     */\r\n    #previousState = \"\";\r\n\r\n    /**\r\n     * @private\r\n     * @type { String }\r\n     * @default \"init\"\r\n     */\r\n    #currentState = \"init\";\r\n\r\n\r\n    /**\r\n     * @private \r\n     * @type { ShadowRoot }\r\n     */\r\n    //#shadow;\r\n\r\n    /**\r\n     * The identifier of the template we inject into the component's ShadowRoot.\r\n     * @private\r\n     * @type { String }\r\n     * @default \"\"\r\n     */\r\n    #template = \"\";\r\n\r\n    /**\r\n     * A private flag to enable / disable manipulation\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #manipulationEnable = false;\r\n\r\n    /**\r\n     * A flag to ensure proper getter / setter\r\n     * @private\r\n     * @type { Boolean }\r\n     * @default false\r\n     */\r\n    #isManipulating = false;\r\n\r\n    /**\r\n     * @type { PointerEvent }\r\n     */\r\n     #initialPointer = undefined;\r\n\r\n    /**\r\n     * @type { Array<PointerEvent> }\r\n     */\r\n    #cachedPointers = new Array();\r\n\r\n    #manipulationDuration = 0; // diff between first timeStampand the latest\r\n    #manipulationDeltaX = 0; // diff x axis between first pointEvent and the latest\r\n    #manipulationDeltaY = 0; // diff x axis between first pointEvent and the latest\r\n    #manipulationDistance = 0; // distance between the 2 points\r\n    #manipulationDeltaScale = 0; // a calculated factor for pich / zoom gesture\r\n    #manipulationAngle = 0; // the current angle\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        //this.#shadow = this.attachShadow({ mode: \"open\"});\r\n\r\n        this.#boundDomLoadedHandler = this.#domLoadedHandler.bind(this);\r\n        window.addEventListener(\"DOMContentLoaded\", this.#boundDomLoadedHandler);\r\n\r\n        this.#boundResizeHandler = this.#resizeHandler.bind(this);\r\n\r\n        this.#boundManipulationEnterHandler     = this.#manipulationEnterHandler.bind(this);\r\n        this.#boundManipulationDownHandler      = this.#manipulationDownHandler.bind(this);\r\n        this.#boundManipulationOverHandler      = this.#manipulationOverHandler.bind(this);\r\n        this.#boundManipulationMoveHandler      = this.#manipulationMoveHandler.bind(this);\r\n        this.#boundManipulationOutHandler       = this.#manipulationOutHandler.bind(this);\r\n        this.#boundManipulationUpHandler        = this.#manipulationUpHandler.bind(this);\r\n        this.#boundManipulationLeaveHandler     = this.#manipulationLeaveHandler.bind(this);\r\n        this.#boundManipulationCancelHandler    = this.#manipulationCancelHandler.bind(this);\r\n\r\n        this.classList.add(\"axial_component_base\");\r\n    }\r\n\r\n    ///\r\n    /// PART: WEB COMPONENT\r\n    ///\r\n\r\n    /**\r\n     * Returned an array of attributes we want to observe when the attributeChangedCallback is invoked.\r\n     * @static\r\n     * @returns Array\r\n     */\r\n    static get observedAttributes()\r\n    {\r\n        //console.log(\"AxialComponentBase#observedAttributes()\");\r\n        return new Array();\r\n    }\r\n\r\n    /**\r\n     * Get or Set the template identifier of the template we want to clone in our Shadow Component.\r\n     * The setter invokes the private #buildShadow method to create the structure of the component.\r\n     * @type { String }\r\n     */\r\n    get template() { return this.#template; }\r\n    set template( value )\r\n    {\r\n        if( typeof value !== \"string\" )\r\n        {\r\n            throw new TypeError(\"String value required\");\r\n        }\r\n        if( this.#template == value ) { return; }\r\n        this.#template = value;\r\n        this.#buildShadow();\r\n    }\r\n\r\n\r\n    /**\r\n     * Clone the node of the template into the ShadowRoot of the component\r\n     * @private\r\n     */\r\n    #buildShadow()\r\n    {\r\n        //this.#shadow = this.attachShadow({ mode: \"open\"});\r\n        this.attachShadow({ mode: \"open\"});\r\n\r\n        // see to change template at runtime but in fact who will need really that\r\n        /*\r\n        const children = this.#shadow.children;\r\n        const childrenLength = children.length;\r\n        if( childrenLength > 0 )\r\n        {\r\n            while( this.#shadow.lastChild )\r\n            {\r\n                this.#shadow.removeChild( this.#shadow.lastChild );\r\n            }\r\n        }\r\n        */\r\n       \r\n        \r\n        const template = document.getElementById(this.#template);\r\n        if( template )\r\n        {\r\n            const templateContent = template.content;\r\n            this.shadowRoot.appendChild(templateContent.cloneNode(true));\r\n        }\r\n    }\r\n\r\n    #domLoadedHandler( event )\r\n    {\r\n        window.removeEventListener(\"DOMContentLoaded\", this.#boundDomLoadedHandler);\r\n        this._finalizeComponent();\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    _finalizeComponent() {}\r\n\r\n    /**\r\n     * Web Components Lifecycle : [MDN_docs] Invoked when the custom element is first connected to the document's DOM.\r\n     * @public\r\n     * @override\r\n     */\r\n    connectedCallback()\r\n    {\r\n        //console.log(\"AxialComponentBase.connectedCallback()\");\r\n    }\r\n\r\n    /**\r\n     * Web Components Lifecycle : [MDN_docs] Invoked when the custom element is disconnected from the document's DOM.\r\n     * @public\r\n     * @override\r\n     */\r\n    disconnectedCallback()\r\n    {\r\n        //console.log(\"AxialComponentBase.disconnectedCallback()\");\r\n    }\r\n\r\n    /**\r\n     * Web Components Lifecylce : [MDN_docs] Invoked when the custom element is moved to a new document.\r\n     * @public\r\n     * @override\r\n     */\r\n    adoptedCallback()\r\n    {\r\n        //console.log(\"AxialComponentBase.adoptedCallback()\");\r\n    }\r\n\r\n    /**\r\n     * Web Components Lifecycle : [MDN_docs] Invoked when one of the custom element's attributes is added, removed, or changed.\r\n     * This callback returned if the component is not already connected. That beacause in some cases, you can update a private field before the constructor has ended.\r\n     * The framework is designed to match all cases ie:\r\n     *  - create a web component directly in the html file\r\n     *  - create a component dynamically\r\n     * @param { String } name - The name of the attribute that has changed.\r\n     * @param { String } oldValue  - The old value of the attribute.\r\n     * @param { String } newValue - The new value of the attribute\r\n     * @public\r\n     * @override\r\n     */\r\n    attributeChangedCallback(name, oldValue, newValue)\r\n    {\r\n        if( this.isConnected == false ) { return; }\r\n        console.log(\"AxialComponentBase.attributeChangedCallback()\");\r\n        console.log(name);\r\n    }\r\n\r\n    ///\r\n    /// PART: DATA\r\n    ///\r\n\r\n    /**\r\n     * Get or set data of the component.\r\n     * @public\r\n     * @type { any }\r\n     * @param { any } value \r\n     */\r\n    get data() { return this.#data; }\r\n    set data( value )\r\n    {\r\n        if( this.#data == value ) { return; }\r\n        this.#data = value;\r\n        this._onDataChanged();\r\n        const dataChangedEvent = new CustomEvent(\"dataChanged\", { detail: this.#data });\r\n        this.dispatchEvent(dataChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * This method is called once the data property has just been setted and before the AxialComponentBase dispatches the dataChanged Custom Event.\r\n     * @public\r\n     * @abstract\r\n     */\r\n    _onDataChanged()\r\n    {\r\n        console.log(\"AxialComponentBase._onDataChanged()\");\r\n    }\r\n\r\n    ///\r\n    /// PART: RESIZE\r\n    ///\r\n\r\n    /**\r\n     * Make the component resizable or not when the window is resized.\r\n     * @public\r\n     * @type { Boolean }\r\n     * @param { Boolean } value \r\n     * @default false\r\n     */\r\n    get isResizable() { return this.#isResizable; }\r\n    set isResizable( value )\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value required\");\r\n        }\r\n        if( this.#isResizable == value ) { return; }\r\n        this.#isResizable = value;\r\n        \r\n        if( this.#isResizable == false )\r\n        {\r\n            window.removeEventListener(\"resize\", this.#boundResizeHandler); // see for bubbling etc.\r\n        }\r\n        else\r\n        {\r\n            window.addEventListener(\"resize\", this.#boundResizeHandler); // see for bubbling etc.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The handler of the window resize event, bounded into the Axial component.\r\n     * @param { Event } event - The resize event.\r\n     */\r\n    #resizeHandler(event)\r\n    {\r\n        this._resize();\r\n    }\r\n\r\n    /**\r\n     * If the AxialComponentBase.isResizable property is setted to true, this method is called each time the window is resized.\r\n     * @public\r\n     * @abstract\r\n     */\r\n    _resize() {}\r\n\r\n    ///\r\n    /// PART: STATES\r\n    ///\r\n\r\n    /**\r\n     * Return all the registered states as an Array of strings.\r\n     * @public\r\n     * @readonly\r\n     * @return { Array.<String> }\r\n     */\r\n    get states() { return Array.from(this.#states); }\r\n\r\n    /**\r\n     * Indicates if the component uses states. If it uses states, the component dispatch the \"stateChanged\" CustomEvent when the switchToState method is called successfully.\r\n     * @public\r\n     * @type { Boolean }\r\n     * @param { Boolean } value \r\n     * @default false\r\n     */\r\n    get useStates() { return this.#useStates; }\r\n    set useStates( value )\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value required\");\r\n        }\r\n        if( this.#useStates == value ) { return; }\r\n        this.#useStates = value;\r\n    }\r\n    /**\r\n     * Get the previous state of the component. Returns an empty string if the state of the component has not changed since it were created.\r\n     * @public\r\n     * @readonly\r\n     * @return { String }\r\n     */\r\n    get previousState() { return this.#previousState; }\r\n\r\n    /**\r\n     * Get the previous state of the component. Returns an empty string if the state of the component has not changed since it were created.\r\n     * @public\r\n     * @readonly\r\n     * @return { String }\r\n     */\r\n    get currentState() { return this.#currentState; }\r\n\r\n    /**\r\n     * Called when the component current state changes successfully.\r\n     * @public\r\n     */\r\n    _onStateChanged()\r\n    {\r\n        console.log(\"AxialComponentBase._onStateChanged()\");\r\n    }\r\n\r\n    /**\r\n     * Add a new state to the states registry of the component.\r\n     * @public\r\n     * @param { String } stateName The name of the new state.\r\n     */\r\n    addState( stateName )\r\n    {\r\n        if( typeof stateName !== \"string\" )\r\n        {\r\n            throw new TypeError(\"String value required\");\r\n        }\r\n        this.#states.add(stateName);\r\n    }\r\n\r\n    /**\r\n     * Delete the state from the states registry of the component. Throws an error if the state is not registered yet.\r\n     * @public\r\n     * @param { String } stateName The name of the state to delete.\r\n     */\r\n    deleteState( stateName )\r\n    {\r\n        if( typeof stateName !== \"string\" )\r\n        {\r\n            throw new TypeError(\"String value required\");\r\n        }\r\n        if( this.#states.has(stateName) == false )\r\n        {\r\n            throw new Error(`The state \"${stateName}\" is not registered`);\r\n        }\r\n        this.#states.delete(stateName);\r\n    }\r\n\r\n    /**\r\n     * Change the state of the component to a new state that has been already registered with the addState method.\r\n     * @param { String } stateName The name of new state.\r\n     */\r\n    switchToState( stateName )\r\n    {\r\n        if( typeof stateName !== \"string\" )\r\n        {\r\n            throw new TypeError(\"String value required\");\r\n        }\r\n        if( this.#states.has(stateName) == false )\r\n        {\r\n            throw new Error(`The state \"${stateName}\" is not registered`);\r\n        }\r\n        if( this.#currentState != stateName )\r\n        {\r\n            this.#previousState = this.#currentState;\r\n            this.#currentState = stateName;\r\n            this._onStateChanged();\r\n\r\n            const stateChangedEventDetail = { newState: this.#currentState, oldState: this.#previousState };\r\n            const stateChangedEvent = new CustomEvent(\"stateChanged\", { detail: stateChangedEventDetail });\r\n            this.dispatchEvent(stateChangedEvent);\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// PART: MANIPULATION\r\n    ///\r\n\r\n    /**\r\n     * Get or set the possibility to manipulate an AxialComponent.\r\n     * @type { Boolean }\r\n     */\r\n    get manipulationEnable() { return this.#manipulationEnable; }\r\n    set manipulationEnable(value)\r\n    {\r\n        if( typeof value !== \"boolean\" )\r\n        {\r\n            throw new TypeError(\"Boolean value required\");\r\n        }\r\n        if( this.#isManipulating == true ) { return; }\r\n        if( this.#manipulationEnable == value ) { return; }\r\n        \r\n        this.#manipulationEnable = value;\r\n        this.#manipulationEnable == false ? this.#removeManipulationHandlers() : this.#addManipulationHandlers();\r\n    }\r\n\r\n    /**\r\n     * A getter to know if a manipulation occurs.\r\n     * @public\r\n     * @type {Boolean }\r\n     * @readonly\r\n     */\r\n    get isManipulating() { return this.#isManipulating; }\r\n\r\n    /**\r\n     * Get the index of the cached PointerEvent by its pointerId.\r\n     * @private\r\n     * @param { PointerEvent } pointer \r\n     * @returns { Number } The index of the cached PointerEvent\r\n     */\r\n    #getCachedPointerIndex( pointer = undefined )\r\n    {\r\n        const isPointer = pointer instanceof PointerEvent;\r\n        if( isPointer == false )\r\n        {\r\n            throw new TypeError( \"PointerEvent value required\" );\r\n        }\r\n        \r\n        const cachedPointersLength = this.#cachedPointers.length;\r\n        if( cachedPointersLength == 0 ) { return undefined; }\r\n\r\n        let indexToReturn = -1;\r\n        const pointerId = pointer.pointerId;\r\n\r\n        for( let i = 0; i < cachedPointersLength; i++ )\r\n        {\r\n            const pe = this.#cachedPointers[i];\r\n            const id = pe.pointerId;\r\n            if( pointerId == id )\r\n            {\r\n                indexToReturn =  i;\r\n                break;\r\n            }\r\n        }\r\n        return indexToReturn;\r\n    }\r\n\r\n    /**\r\n     * Re initialize variables we need to manage the different gestures.\r\n     * @private\r\n     */\r\n    #restartManipulation()\r\n    {\r\n        this.#initialPointer = undefined;\r\n        this.#cachedPointers = new Array();\r\n        this.#isManipulating = false;\r\n\r\n        this.#manipulationDuration = 0;\r\n        this.#manipulationDeltaX = 0;\r\n        this.#manipulationDeltaY = 0;\r\n        this.#manipulationDistance = 0;\r\n        this.#manipulationDeltaScale = 0;\r\n        this.#manipulationAngle = 0;\r\n    }\r\n\r\n    /**\r\n     * Util method to send the states of the current manipulation.\r\n     * @returns { Object }\r\n     */\r\n    #createManipulationEventDetail()\r\n    {\r\n        const manipulationEventDetail =\r\n        {\r\n            duration: this.#manipulationDuration,\r\n            deltaX: this.#manipulationDeltaX,\r\n            deltaY: this.#manipulationDeltaY,\r\n            distance: this.#manipulationDistance,\r\n            scale: this.#manipulationDeltaScale,\r\n            angle: this.#manipulationAngle\r\n        }\r\n        return manipulationEventDetail;\r\n    }\r\n\r\n    /**\r\n     * The main method that handles the manipulation, the gestures.\r\n     * @param { PointerEvent } event\r\n     */\r\n    #handleManipulation(event)\r\n    {\r\n        // no bubbling, we are focused on the element itself\r\n        event.stopPropagation();\r\n\r\n        // only touches for the moment\r\n        if( event.pointerType != \"touch\" ) { return; }\r\n        \r\n        // get the event type for exclusions\r\n        const eventType = event.type;\r\n\r\n        // just down, move up and cancel right now so no need to process others\r\n        if( eventType == \"pointerover\" || eventType == \"pointerenter\" || eventType == \"pointerout\" || eventType == \"pointerleave\" )\r\n        {\r\n            return;\r\n        }\r\n\r\n        console.log(eventType);\r\n\r\n        // POINTER CANCEL\r\n        if( eventType == \"pointercancel\" )\r\n        {\r\n            // CANCEL ALL\r\n            const manipulationEventDetail = this.#createManipulationEventDetail();\r\n            const manipulationCancelledEvent = new CustomEvent(\"manipulationCancelled\", { detail: manipulationEventDetail });\r\n            this.dispatchEvent(manipulationCancelledEvent);\r\n            this.#restartManipulation();\r\n            return;\r\n        }\r\n\r\n        const cachedPointersLength = this.#cachedPointers.length;\r\n        //console.log(\"init cachedPointersLength = \" + cachedPointersLength);\r\n    \r\n        // down (maybe add a check on timestamp in case a cached pointer still in the array)\r\n        if( eventType == \"pointerdown\" )\r\n        {\r\n            if( cachedPointersLength == 0 )\r\n            {\r\n                this.#initialPointer = event;\r\n                this.#cachedPointers.push(event);\r\n                this.#isManipulating = true;\r\n\r\n                // DISPATCH\r\n                const manipulationEventDetail = this.#createManipulationEventDetail();\r\n                const manipulationStartedEvent = new CustomEvent(\"manipulationStarted\", { detail: manipulationEventDetail });\r\n                this.dispatchEvent(manipulationStartedEvent);\r\n            }\r\n            else if( cachedPointersLength == 1 )\r\n            {\r\n                this.#cachedPointers.push(event);\r\n\r\n                // MANIPULATION OBJECT\r\n                this.#manipulationDuration = event.timeStamp - this.#initialPointer.timeStamp;\r\n                // distance\r\n                // angle\r\n\r\n                // DISPATCH\r\n                const manipulationEventDetail = this.#createManipulationEventDetail();\r\n                const manipulationChangedEvent = new CustomEvent(\"manipulationChanged\", { detail: manipulationEventDetail });\r\n                this.dispatchEvent(manipulationChangedEvent);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // if event not registered we can return\r\n        const currentPointerIndex = this.#getCachedPointerIndex(event);\r\n        if( currentPointerIndex == -1 ) { return; }\r\n        //console.log(\"currentPointerIndex = \" + currentPointerIndex);\r\n\r\n        // we can update the duration here\r\n        this.#manipulationDuration = event.timeStamp - this.#initialPointer.timeStamp;\r\n\r\n        // now we can deal with the moves :)\r\n        // move\r\n        if( eventType == \"pointermove\" )\r\n        {\r\n            // just one pointer for the moment\r\n            if( cachedPointersLength == 1 )\r\n            {\r\n                // get the first pointer\r\n                const cachedPointer = this.#cachedPointers[currentPointerIndex];\r\n\r\n                this.#manipulationDeltaX = event.pageX - cachedPointer.pageX;\r\n                this.#manipulationDeltaY = event.pageY - cachedPointer.pageY;\r\n                // we have only one point : but maybe two on the previous move so re init the \"2 points vars\"\r\n                this.#manipulationDistance = 0;\r\n                this.#manipulationDeltaScale = 0;\r\n                this.#manipulationAngle = 0;\r\n\r\n                // DISPATCH\r\n                const manipulationEventDetail = this.#createManipulationEventDetail();\r\n                const manipulationChangedEvent = new CustomEvent(\"manipulationChanged\", { detail: manipulationEventDetail });\r\n                this.dispatchEvent(manipulationChangedEvent);\r\n\r\n                // update cached pointers\r\n                this.#cachedPointers[currentPointerIndex] = event;\r\n            }\r\n            else if( cachedPointersLength == 2 )\r\n            {\r\n\r\n            }\r\n            // DISPATCH\r\n        }\r\n\r\n        // up\r\n        if( eventType == \"pointerup\" )\r\n        {\r\n            if( this.#cachedPointers.length == 2 )\r\n            {\r\n\r\n            }\r\n            else if( this.#cachedPointers.length == 1 )\r\n            {\r\n                // get the first pointer\r\n                const cachedPointer = this.#cachedPointers[currentPointerIndex];\r\n\r\n                this.#manipulationDeltaX = event.pageX - cachedPointer.pageX;\r\n                this.#manipulationDeltaY = event.pageY - cachedPointer.pageY;\r\n                // we have only one point : but maybe two on the previous move so re init the \"2 points vars\"\r\n                this.#manipulationDistance = 0;\r\n                this.#manipulationDeltaScale = 0;\r\n                this.#manipulationAngle = 0;\r\n\r\n                // DISPATCH\r\n                const manipulationEventDetail = this.#createManipulationEventDetail();\r\n                const manipulationChangedEvent = new CustomEvent(\"manipulationFinished\", { detail: manipulationEventDetail });\r\n                this.dispatchEvent(manipulationChangedEvent);\r\n\r\n            }\r\n            this.#cachedPointers.splice(currentPointerIndex,1);\r\n            return;\r\n        }\r\n\r\n        \r\n        //console.log(\"final pointersLength = \" + this.#cachedPointers.length);\r\n    }\r\n\r\n    #addManipulationHandlers()\r\n    {\r\n        this.addEventListener(\"pointerenter\", this.#boundManipulationEnterHandler);\r\n        this.addEventListener(\"pointerdown\", this.#boundManipulationDownHandler);\r\n        this.addEventListener(\"pointerover\", this.#boundManipulationOverHandler);\r\n        this.addEventListener(\"pointermove\", this.#boundManipulationMoveHandler);\r\n        this.addEventListener(\"pointerout\", this.#boundManipulationOutHandler);\r\n        this.addEventListener(\"pointerup\", this.#boundManipulationUpHandler);\r\n        this.addEventListener(\"pointerleave\", this.#boundManipulationLeaveHandler);\r\n        this.addEventListener(\"pointercancel\", this.#boundManipulationCancelHandler);\r\n    }\r\n\r\n    #removeManipulationHandlers()\r\n    {\r\n        this.removeEventListener(\"pointerover\", this.#boundManipulationOverHandler);\r\n        this.removeEventListener(\"pointerenter\", this.#boundManipulationEnterHandler);\r\n        this.removeEventListener(\"pointerdown\", this.#boundManipulationDownHandler);\r\n        this.removeEventListener(\"pointermove\", this.#boundManipulationMoveHandler);\r\n        this.removeEventListener(\"pointerup\", this.#boundManipulationUpHandler);\r\n        this.removeEventListener(\"pointerout\", this.#boundManipulationOutHandler);\r\n        this.removeEventListener(\"pointerleave\", this.#boundManipulationLeaveHandler);\r\n        this.removeEventListener(\"pointercancel\", this.#boundManipulationCancelHandler);\r\n    }\r\n\r\n    #manipulationOverHandler(event) \r\n    {\r\n        //console.log(\"pointer over\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationEnterHandler(event)\r\n    {\r\n        //console.log(\"pointer enter\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationDownHandler(event)\r\n    {\r\n        //console.log(\"pointer down\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationMoveHandler(event)\r\n    {\r\n        //console.log(\"pointer move\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationUpHandler(event)\r\n    {\r\n        //console.log(\"pointer up\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationOutHandler(event)\r\n    {\r\n        //console.log(\"pointer out\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationLeaveHandler(event)\r\n    {\r\n        //console.log(\"pointer leave\");\r\n        this.#handleManipulation(event);\r\n    }\r\n\r\n    #manipulationCancelHandler(event)\r\n    {\r\n        //console.log(\"pointer cancel\");\r\n        this.#handleManipulation(event);\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"axial-component-base\", AxialComponentBase);\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/core/AxialComponentBase.js?");

/***/ }),

/***/ "./axial/js/geom/Point.js":
/*!********************************!*\
  !*** ./axial/js/geom/Point.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Point\": () => (/* binding */ Point)\n/* harmony export */ });\n\r\n\r\nclass Point\r\n{\r\n    #x;\r\n    #y;\r\n    \r\n    /**\r\n     * Create a point. \r\n     * @param { Number } x \r\n     * @param { Number } y \r\n     */\r\n    constructor( x = 0, y = 0)\r\n    {\r\n        this.#x = x;\r\n        this.#y = y;\r\n    }\r\n\r\n    get x() { return this.#x; }\r\n    set x( value )\r\n    {\r\n        if( isNaN( value ) == true )\r\n        {\r\n            throw new TypeError(\"Number value expected\");\r\n        }\r\n        this.#x = value;\r\n    }\r\n\r\n    get y() { return this.#y; }\r\n    set y( value )\r\n    {\r\n        if( isNaN( value ) == true )\r\n        {\r\n            throw new TypeError(\"Number value expected\");\r\n        }\r\n        this.#y = value;\r\n    }\r\n\r\n    /**\r\n     * Calculate the distance between 2 given points. \r\n     * @param { Point } p1 \r\n     * @param { Point } p2 \r\n     * @return { Number }\r\n     */\r\n    static distance(p1, p2)\r\n    {\r\n        let dx = p1.#x - p2.#x;\r\n        let dy = p1.#y - p2.#y;\r\n\r\n        return Math.hypot(dx, dy);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param { Point } p1 \r\n     * @param { Point } p2 \r\n     * @return { Point }\r\n     */\r\n    static middlePoint(p1, p2)\r\n    {\r\n        return new Point( ((p1.#x + p2.#x) / 2) , ((p1.#y + p2.#y) / 2) );\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/geom/Point.js?");

/***/ }),

/***/ "./axial/js/utils/LanguageUtils.js":
/*!*****************************************!*\
  !*** ./axial/js/utils/LanguageUtils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LanguageUtils\": () => (/* binding */ LanguageUtils)\n/* harmony export */ });\n\r\n\r\nclass LanguageUtils\r\n{\r\n    /**\r\n     * @return { String } - the lower case 2 chars language string\r\n     */\r\n    static getNavigatorLanguage()\r\n    {\r\n        let finalLanguage = undefined;\r\n        const splitter = \"-\";\r\n        let currentLanguage = navigator.language;\r\n        if( currentLanguage.indexOf(splitter) > 0 )\r\n        {\r\n            let languages = currentLanguage.split(splitter);\r\n            finalLanguage = languages[0].toLowerCase();\r\n        }\r\n        else\r\n        {\r\n            finalLanguage = currentLanguage.toLowerCase();\r\n        }\r\n        return finalLanguage;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./axial/js/utils/LanguageUtils.js?");

/***/ }),

/***/ "./project/js/DndApplicationBase.js":
/*!******************************************!*\
  !*** ./project/js/DndApplicationBase.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DndApplicationBase\": () => (/* binding */ DndApplicationBase)\n/* harmony export */ });\n/* harmony import */ var _axial_js_core_AxialApplicationBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../axial/js/core/AxialApplicationBase */ \"./axial/js/core/AxialApplicationBase.js\");\n/* harmony import */ var _axial_js_button_AxialButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../axial/js/button/AxialButton */ \"./axial/js/button/AxialButton.js\");\n/* harmony import */ var _axial_js_button_AxialToggleButtonGroupBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../axial/js/button/AxialToggleButtonGroupBase */ \"./axial/js/button/AxialToggleButtonGroupBase.js\");\n/* harmony import */ var _axial_js_button_AxialToggleSwitch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../axial/js/button/AxialToggleSwitch */ \"./axial/js/button/AxialToggleSwitch.js\");\n/* harmony import */ var _axial_js_button_AxialToggleRadio__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../axial/js/button/AxialToggleRadio */ \"./axial/js/button/AxialToggleRadio.js\");\n\r\n\r\n;\r\n\r\n// import components here\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass DndApplicationBase extends _axial_js_core_AxialApplicationBase__WEBPACK_IMPORTED_MODULE_0__.AxialApplicationBase\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        console.log(\"Hello DndApplicationBase\");\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./project/js/DndApplicationBase.js?");

/***/ }),

/***/ "./project/js/components/DndContactForm.js":
/*!*************************************************!*\
  !*** ./project/js/components/DndContactForm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DndContactForm\": () => (/* binding */ DndContactForm)\n/* harmony export */ });\n/* harmony import */ var _axial_js_core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../axial/js/core/AxialComponentBase */ \"./axial/js/core/AxialComponentBase.js\");\n\r\n\r\n;\r\n\r\nclass DndContactForm extends _axial_js_core_AxialComponentBase__WEBPACK_IMPORTED_MODULE_0__.AxialComponentBase\r\n{\r\n    \r\n    /** @type { HTMLInputElement } */\r\n    #messageEmail;\r\n    /** @type { HTMLTextAreaElement } */\r\n    #messageText;\r\n    /** @type { HTMLElement } */\r\n    #messageButton;\r\n\r\n    #boundMessageButtonClickHandler;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        console.log(\"Hello component DndContactForm\");\r\n        this.#boundMessageButtonClickHandler = this.messageButtonClickHandler.bind(this);\r\n        this.template = \"dnd-contact-form-template\";\r\n        \r\n    }\r\n\r\n    connectedCallback()\r\n    {\r\n        this.#messageEmail = this.shadowRoot.getElementById(\"messageEmail\");\r\n        this.#messageText = this.shadowRoot.getElementById(\"messageText\");\r\n        this.#messageButton = this.shadowRoot.getElementById(\"messageButton\");\r\n        if( this.#messageButton )\r\n        {\r\n            this.#messageButton.addEventListener(\"click\", this.#boundMessageButtonClickHandler);\r\n        }\r\n        console.log(this.#messageButton);\r\n    }\r\n\r\n    messageButtonClickHandler( event )\r\n    {\r\n        console.log(\"click\");\r\n        this.#sendForm();\r\n    }\r\n\r\n    async #sendForm()\r\n    {\r\n        try\r\n        {\r\n            const infos = { email: this.#messageEmail.value, text: this.#messageText.value }\r\n            const response = await fetch(\"./post/mail\", { method: \"POST\", body: JSON.stringify(infos), headers: {\"Content-Type\": \"application/json\"} });\r\n            const json = await response.json();\r\n            console.log(json)\r\n        }\r\n        catch(err)\r\n        {\r\n            console.log(err);\r\n        }\r\n    }\r\n}\r\n\r\nwindow.customElements.define(\"dnd-contact-form\", DndContactForm);\r\n\n\n//# sourceURL=webpack:///./project/js/components/DndContactForm.js?");

/***/ }),

/***/ "./project/pages/main/js/DndMainPage.js":
/*!**********************************************!*\
  !*** ./project/pages/main/js/DndMainPage.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DndMainPage\": () => (/* binding */ DndMainPage)\n/* harmony export */ });\n/* harmony import */ var _js_DndApplicationBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../js/DndApplicationBase */ \"./project/js/DndApplicationBase.js\");\n/* harmony import */ var _js_components_DndContactForm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../js/components/DndContactForm */ \"./project/js/components/DndContactForm.js\");\n\r\n\r\n;\r\n\r\n\r\nclass DndMainPage extends _js_DndApplicationBase__WEBPACK_IMPORTED_MODULE_0__.DndApplicationBase\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        console.log(\"Hello DndMainPage\");\r\n    }\r\n    \r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./project/pages/main/js/DndMainPage.js?");

/***/ }),

/***/ "./project/pages/main/js/Page.js":
/*!***************************************!*\
  !*** ./project/pages/main/js/Page.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DndMainPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DndMainPage */ \"./project/pages/main/js/DndMainPage.js\");\n\r\n;\r\nconst DND_MAIN_PAGE = new _DndMainPage__WEBPACK_IMPORTED_MODULE_0__.DndMainPage();\n\n//# sourceURL=webpack:///./project/pages/main/js/Page.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./project/pages/main/js/Page.js");
/******/ 	
/******/ })()
;